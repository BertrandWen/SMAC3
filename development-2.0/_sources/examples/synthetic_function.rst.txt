
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "examples/synthetic_function.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_examples_synthetic_function.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_examples_synthetic_function.py:


Synthetic Function
^^^^^^^^^^^^^^^^^^

An example of applying SMAC to optimize a synthetic function (2D Rosenbrock function).

We use the black-box facade because it is designed for black-box function optimization.
The black-box facade uses a :term:`Gaussian Process<GP>` as its surrogate model.
The facade works best on numerical hyperparameter configuration space and should not
be applied to problems with large evaluation budgets (up to 1000 evaluations).

.. GENERATED FROM PYTHON SOURCE LINES 12-56




.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Default value: 16916.0
    [INFO][initial_design.py:82] Ignoring `configs` and `n_configs_per_hyperparameter` since `n_configs` is given.
    [INFO][smbo.py:144] Running initial design...
    [INFO][initial_design.py:155] Retrieving 10 configurations for the initial design.
    [INFO][intensification.py:249] No incumbent provided in the first run. Sampling a new challenger...
    [INFO][intensification.py:448] First run and no incumbent provided. Challenger is assumed to be the incumbent.
    [INFO][intensification.py:609] Updated estimated cost of incumbent on 1 runs: 1102.7878
    [INFO][abstract_intensifier.py:333] Challenger (993.2254) is better than incumbent (1102.7878) on 1 runs.
    [INFO][abstract_intensifier.py:353] Changes in incumbent:
    [INFO][abstract_intensifier.py:356] --- x0: -0.9968221839517355 -> 0.38492917509448077
    [INFO][abstract_intensifier.py:356] --- x1: 4.30847043171525 -> -3.002777126963477
    [INFO][abstract_intensifier.py:333] Challenger (916.5753) is better than incumbent (993.2254) on 1 runs.
    [INFO][abstract_intensifier.py:353] Changes in incumbent:
    [INFO][abstract_intensifier.py:356] --- x0: 0.38492917509448077 -> 0.39261850860679015
    [INFO][abstract_intensifier.py:356] --- x1: -3.002777126963477 -> -2.872740864477837
    [INFO][abstract_intensifier.py:333] Challenger (866.0216) is better than incumbent (916.5753) on 1 runs.
    [INFO][abstract_intensifier.py:353] Changes in incumbent:
    [INFO][abstract_intensifier.py:356] --- x0: 0.39261850860679015 -> 0.36020319516931654
    [INFO][abstract_intensifier.py:356] --- x1: -2.872740864477837 -> -2.812382511937239
    [INFO][abstract_intensifier.py:333] Challenger (474.6644) is better than incumbent (866.0216) on 1 runs.
    [INFO][abstract_intensifier.py:353] Changes in incumbent:
    [INFO][abstract_intensifier.py:356] --- x0: 0.36020319516931654 -> 0.2783949428956394
    [INFO][abstract_intensifier.py:356] --- x1: -2.812382511937239 -> -2.09998038849629
    [INFO][abstract_intensifier.py:333] Challenger (434.0075) is better than incumbent (474.6644) on 1 runs.
    [INFO][abstract_intensifier.py:353] Changes in incumbent:
    [INFO][abstract_intensifier.py:356] --- x0: 0.2783949428956394 -> 0.22713983550245587
    [INFO][abstract_intensifier.py:356] --- x1: -2.09998038849629 -> -2.0302580009030775
    [INFO][abstract_intensifier.py:333] Challenger (385.3632) is better than incumbent (434.0075) on 1 runs.
    [INFO][abstract_intensifier.py:353] Changes in incumbent:
    [INFO][abstract_intensifier.py:356] --- x0: 0.22713983550245587 -> 0.24160438072802304
    [INFO][abstract_intensifier.py:356] --- x1: -2.0302580009030775 -> -1.9032288313052792
    [INFO][abstract_intensifier.py:333] Challenger (209.2384) is better than incumbent (385.3632) on 1 runs.
    [INFO][abstract_intensifier.py:353] Changes in incumbent:
    [INFO][abstract_intensifier.py:356] --- x0: 0.24160438072802304 -> 0.562791988268331
    [INFO][abstract_intensifier.py:356] --- x1: -1.9032288313052792 -> -1.1291118119238912
    [INFO][abstract_intensifier.py:333] Challenger (22.7563) is better than incumbent (209.2384) on 1 runs.
    [INFO][abstract_intensifier.py:353] Changes in incumbent:
    [INFO][abstract_intensifier.py:356] --- x0: 0.562791988268331 -> 0.5287690919442625
    [INFO][abstract_intensifier.py:356] --- x1: -1.1291118119238912 -> -0.19510570233752578
    [INFO][facade.py:320] Final Incumbent: {'x0': 0.5287690919442625, 'x1': -0.19510570233752578}
    [INFO][facade.py:321] Estimated cost: 22.756300640656857
    Incumbent value: 22.76






|

.. code-block:: default


    from ConfigSpace import Configuration, ConfigurationSpace, Float

    from smac import BlackBoxFacade, Scenario

    __copyright__ = "Copyright 2021, AutoML.org Freiburg-Hannover"
    __license__ = "3-clause BSD"


    def rosenbrock_2d(x: Configuration) -> float:
        """The 2-dimensional Rosenbrock function as a toy model.
        The Rosenbrock function is well know in the optimization community and
        often serves as a toy problem. It can be defined for arbitrary
        dimensions. The minimium is always at x_i = 1 with a function value of
        zero. All input parameters are continuous. The search domain for
        all x's is the interval [-5, 10].
        """
        x1 = x["x0"]
        x2 = x["x1"]

        cost = 100.0 * (x2 - x1**2.0) ** 2.0 + (1 - x1) ** 2.0
        return cost


    if __name__ == "__main__":
        # Build configuration space which defines all parameters and their ranges
        configspace = ConfigurationSpace()
        x0 = Float("x0", (-5, 10), default=-3)
        x1 = Float("x1", (-5, 10), default=-4)
        configspace.add_hyperparameters([x0, x1])

        # Scenario object
        scenario = Scenario(configspace, n_runs=100)

        # Example call of the target algorithm
        default_value = rosenbrock_2d(configspace.get_default_configuration())
        print(f"Default value: {round(default_value, 2)}")

        # Now we use SMAC to find the best hyperparameters
        smac = BlackBoxFacade(scenario, rosenbrock_2d)
        incumbent = smac.optimize()

        incumbent_value = rosenbrock_2d(incumbent)
        print(f"Incumbent value: {round(incumbent_value, 2)}")


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  1.173 seconds)


.. _sphx_glr_download_examples_synthetic_function.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example


    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: synthetic_function.py <synthetic_function.py>`

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: synthetic_function.ipynb <synthetic_function.ipynb>`
